import streamlit as st
import fitz  # PyMuPDF
import html
from datetime import datetime
from typing import List

st.set_page_config(page_title="Judgment → HTML (faithful extract)", layout="wide", page_icon="⚖️")

st.title("Judgment → HTML — faithful text extraction")
st.markdown(
    "Uploads a judgment PDF and creates an HTML preserving **exact line breaks, numbering and sub-numbering**. "
    "If the PDF is scanned (images only) you must OCR it first."
)

st.sidebar.header("Options")
preserve_nbsp = st.sidebar.checkbox("Keep non-breaking spaces (NBSP)", value=False,
                                     help="If checked, NBSPs remain as \\u00A0; otherwise they convert to normal spaces.")
remove_soft_hyphen = st.sidebar.checkbox("Remove soft-hyphen (\\u00AD)", value=True,
                                         help="Soft-hyphens cause visual split words; removing them usually fixes broken words.")
font_size = st.sidebar.slider("Font size in preview (px)", 12, 20, 14)
mono = st.sidebar.checkbox("Use monospace font in preview", value=False)
upload = st.file_uploader("Upload judgment PDF", type=["pdf"])

if not upload:
    st.info("Please upload a PDF to extract.")
    st.stop()

pdf_bytes = upload.read()
if not pdf_bytes:
    st.error("Uploaded file appears empty.")
    st.stop()

def extract_lines_from_page(page: fitz.Page) -> List[str]:
    """
    Extract lines from a page by reading page.get_text('dict') and joining spans ordered by x position.
    This preserves the reading order and keeps the original line breaks.
    """
    d = page.get_text("dict")
    lines = []
    for block in d.get("blocks", []):
        if block.get("type") != 0:
            # skip non-text blocks (images)
            continue
        for line in block.get("lines", []):
            # sort spans by x0 (bbox[0]) to ensure left-to-right order
            spans = sorted(line.get("spans", []), key=lambda s: s.get("bbox", [0,0,0,0])[0])
            txt = "".join(s.get("text", "") for s in spans)
            lines.append(txt)
    return lines

def normalize_line(s: str) -> str:
    # Optionally remove soft-hyphen and normalize NBSP
    if remove_soft_hyphen:
        s = s.replace("\u00ad", "")  # soft hyphen removal
    if not preserve_nbsp:
        s = s.replace("\u00a0", " ")
    # Some PDFs include weird control chars — remove isolated vertical tabs etc.
    s = s.replace("\x0b", " ").replace("\r", "")
    return s

def page_to_pre_html(page: fitz.Page, page_index: int) -> str:
    raw_lines = extract_lines_from_page(page)
    cleaned = [normalize_line(ln) for ln in raw_lines]
    page_text = "\n".join(cleaned).rstrip() + ("\n" if cleaned and not cleaned[-1].endswith("\n") else "")
    esc = html.escape(page_text)
    # Unique id per page
    return f'<pre class="prepage" id="page{page_index}">{esc}</pre>'

# Process file while keeping doc open (avoids 'document closed' race)
try:
    with fitz.open(stream=pdf_bytes, filetype="pdf") as doc:
        page_html_snippets = []
        n = doc.page_count
        progress = st.progress(0)
        status = st.empty()
        for i in range(n):
            status.info(f"Extracting page {i+1}/{n} …")
            page = doc.load_page(i)
            page_html_snippets.append(page_to_pre_html(page, i+1))
            progress.progress((i+1)/n)
        status.success("Extraction finished.")
except Exception as e:
    st.exception(e)
    st.stop()

# Compose final HTML
title = (upload.name or "Judgment").rsplit(".", 1)[0]
now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

css_font = "monospace" if mono else "serif"
css = f"""
<style>
  :root {{ --bg: #ffffff; --meta:#f6f7f8; }}
  html,body{{ margin:0;padding:0;background:var(--bg);color:#111;font-family:{css_font}, Georgia, 'Times New Roman', serif; }}
  .doc-meta{{font:12px/1.4 system-ui, sans-serif;color:#444;background:var(--meta);padding:10px 14px;border-bottom:1px solid #e5e7eb}}
  .container{{padding:18px;}}
  .prepage{{ white-space: pre-wrap; /* preserves line breaks and long lines wrap */ 
            font-size: {font_size}px;
            line-height: 1.45;
            margin: 14px auto;
            max-width: 980px;
            padding: 14px;
            box-sizing: border-box;
            border: 0px solid transparent;
          }}
  /* small page separation */
  .page-sep{{ height: 28px; }}
</style>
"""

pages_joined = "\n<div class='page-sep'></div>\n".join(page_html_snippets)
final_html = f"""<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>{html.escape(title)}</title>
{css}
</head>
<body>
  <div class="doc-meta">Generated by Judgment → HTML on {now} — source: {html.escape(upload.name or '')}</div>
  <div class="container">
    {pages_joined}
  </div>
</body>
</html>
"""

# Preview in Streamlit (tall iframe)
st.subheader("Preview (faithful)")
st.components.v1.html(final_html, height=900, scrolling=True)

# Download
st.download_button("⬇️ Download faithful HTML", data=final_html.encode("utf-8"),
                   file_name=f"{title}_faithful.html", mime="text/html")

st.info("Notes: This method reconstructs **exact lines** from the PDF. If the PDF is scanned (image-only), run OCR first (e.g., OCRmyPDF).")
